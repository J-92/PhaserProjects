<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Avoidance</title>
    <script src="phaser.js"></script>
    <script src="avoid_hitboxes.json"></script>
    <script src="avoid_sprites.json"></script>
</head>
<body>
    <script>
       
        class SceneGameOn extends Phaser.Scene {
            constructor(){
            super({ key: 'sceneGameOn' });
                }
            preload() {
                console.log('game is loading')
                // Load sprite sheet generated with TexturePacker
                this.load.atlas('sprites', 'avoid_sprites.png', 'avoid_sprites.json');
                // Load body shapes from JSON file generated using PhysicsEditor
                this.load.json('hitboxes', 'avoid_hitboxes.json');
                }
            create() {
                console.log("game has loaded")
                var scene_obj = this;
                hitboxes = this.cache.json.get('hitboxes');
                var keyNames = Object.keys(hitboxes);
                console.log(keyNames)
                this.matter.world.setBounds(0, 0, game.config.width, game.config.height);

                forest = new ForestGenerator(scene_obj).makeForest(4);
                reds = new J_Sprite(scene_obj, 'red').addMe(2);
                reds.red_1.x = game.config.width*0.5;
                reds.red_1.y = game.config.height*0.5;
                reds.red_1.target = new Point(reds.red_1.x,reds.red_1.y);
                graphicsEffectOne_pt_Init(scene_obj, reds.red_1);
                reds.red_2.x = game.config.width -25;
                reds.red_2.y = 25;
                reds.red_2.setInteractive();
                reds.red_2.on('pointerup', function (event) {
                    this.input.manager.enabled = true;
                    this.scene.start('sceneGameOver');
                        }, this);
                forest.tree_1.start()
                forest.tree_2.start()
                forest.tree_3.start()
                forest.tree_4.start()

                //Use prime numbers to get randomness
                setInterval(function () {
                    forest.tree_1.start()
                    forest.tree_2.start()
                    forest.tree_3.start()
                    forest.tree_4.start()

                },8000, forest)
                }
            update(time, delta){
                var scene_obj = this;
                mouseTarget(scene_obj, reds.red_1);
                moveToMouse(reds.red_1, delta);
                graphicsEffectOne_pt_Update(reds.red_1, delta);
            }
        }
        function mouseTarget(scene_obj, sprite){
            scene_obj.input.manager.enabled = true;
            scene_obj.input.once('pointerdown', function (event) {
                    sprite.target = new Point(game.input.mousePointer.x,game.input.mousePointer.y)
                    }, this);    
        }
        function moveToMouse(sprite, delta){
            //Point the object at its target
            var dx =  sprite.target.x - sprite.x;
            var dy = sprite.target.y - sprite.y;
            var angle = Math.atan2(dy, dx);
            sprite.rotation = angle
            //move the object in the direction its facing
            //calculate the distance to the target
            var hyp = Math.sqrt((dx*dx)+(dy*dy))
            //if the hyp is less then 5 pixels pick a new target
            if (hyp > 5){
                sprite.x = sprite.x+Math.cos(sprite.rotation)*delta/8
                sprite.y = sprite.y+Math.sin(sprite.rotation)*delta/8
            }
            
        };
        
    //////
    //EFFECT TWO START
    //////
    class ForestGenerator{
        constructor(scene_obj){
            this.trees = {}
            this.scene_obj = scene_obj            
        }
        makeForest(num_trees){
        var context_this_forest = this;
        for(var i = num_trees; i > 0; i--){
            var name_it = 'tree_'+i.toString();
            context_this_forest.trees[name_it] = new TreeGenerator(context_this_forest.scene_obj)
        }
        return this.trees
    }
}

    
    class TreeGenerator{
    constructor(scene_obj){
        this.loss = 0.03; // Width loss per cycle
        this.minSleep= 10; // Min sleep time (For the animation)
        this.branchLoss= 0.8; // % width maintained for branches
        this.mainLoss= 0.8; // % width maintained after branching
        this.speed= 0.3; // Movement speed
        this.newBranch= 0.8; // Chance of not starting a new branch
        this.fastMode= true; // Fast growth mode
        this.fadeOut= true; // Fade slowly to black
        this.fadeAmount= 0.05; // How much per iteration
        this.fadeInterval= 250; // Fade interval in ms
        this.initialWidth= 10; // Initial branch width
        this.indicateNewBranch= false; // Display a visual indicator when a new branch is born
        this.fitScreen= false; // Resize canvas to fit screen,
        this.bgColor= [0, 0, 0];
        // Initialize the canvas
        this.canvas = scene_obj 
        this.canvas.ctx = scene_obj.add.graphics()
        // canvasMinX: canvas.offset().left,
        // canvasMaxX: canvas.canvasMinX + canvas.WIDTH,
        // canvasMinY: canvas.offset().top,
        // canvasMaxY: canvas.canvasMinY + canvas.HEIGHT
        // Generation intervals
        this.intervals = {
            generation: null,
            fading: null,
            clear: null
        }
        this.x = 200+Math.random()*600 
        this.y =1         
        this.height = 500
        this.width = 500
        this.new_colour= this.newColor()
    }
    start(){
        var this_tree = this;

this_tree.branch(this_tree.x, this_tree.height, 0, -3, 10, 0, 0, this_tree.new_colour);

this_tree.intervals.generation = setInterval(function () {
    this_tree.branch(this_tree.x,this_tree.heigth,0,-Math.random() * 3,10 * Math.random(), 30,0,this_tree.new_colour);
}, 200, this_tree);

setTimeout(function(){
    this_tree.stopGeneration()
},1000,this_tree) 

setTimeout(function(){
    if (this_tree.fadeOut) {
        this_tree.intervals.fading = setInterval(function () {
            this_tree.fade()
        },200, this_tree);
    }
},4000,this_tree)

setTimeout(function(){
    this_tree.stopFade()
    clear(this_tree)
    },8000,this_tree)
    }

    stopGeneration(){
        var this_tree = this;
        clearInterval(this_tree.intervals.generation);
        
    }
    stopFade(){
        var this_tree = this;
        this_tree.canvas.ctx.alpha = 1;
        clearInterval(this_tree.intervals.fading);
    }
    branch(x, y, dx, dy, w, growthRate, lifetime, branchColor){
        var this_tree = this;
        this_tree.canvas.ctx.lineStyle(w - lifetime * this_tree.loss, this_tree.new_colour);
        this_tree.canvas.ctx.beginPath();
        this_tree.canvas.ctx.moveTo(x, y);
        if (this_tree.fastMode) growthRate *= 0.5;
        // Calculate new coords
        x = x + dx;
        y = y + dy;
        // Change dir
        dx = dx + Math.sin(Math.random() + lifetime) * this_tree.speed;
        dy = dy + Math.cos(Math.random() + lifetime) * this_tree.speed;
        // Check if branches are getting too low
        if (w < 6 && y > this_tree.heigth - Math.random() * (0.3 * this_tree.heigth)) w = w * 0.8;
        // Draw the next segment of the branch
        this_tree.canvas.ctx.strokeStyle = this_tree.treeColor;
        this_tree.canvas.ctx.lineTo(x, y);
        this_tree.canvas.ctx.strokePath();
        // Generate new branches
        // they should spawn after a certain lifetime has been met, although depending on the width
        if (lifetime > 5 * w + Math.random() * 100 && Math.random() > this_tree.newBranch) {
            setTimeout(function () {
                // Indicate the birth of a new branch
                if (this_tree.indicateNewBranch) {
                    circle(this_tree.canvas, x, y, w, this_tree.treeColor);
                }
                this_tree.branch(x, y, 2 * Math.sin(Math.random() + lifetime), 2 * Math.cos(Math.random() + lifetime), (w - lifetime * this_tree.loss) * this_tree.branchLoss, growthRate + Math.random() * 100, 0, branchColor);
                // When it branches, it looses a bit of width
                w *= this_tree.mainLoss;
            }, 2 * growthRate * Math.random() + this_tree.minSleep);
        }
        // Continue the branch
        if (w - lifetime * this_tree.loss >= 1) setTimeout(function () {
            this_tree.branch(x, y, dx, dy, w, growthRate, ++lifetime, branchColor);
        }, growthRate);
    }
    resizeCanvas(){
        this.canvas.WIDTH = window.innerWidth;
        this.canvas.HEIGHT = window.innerHeight;

        this.canvas.el.attr('width', canvas.WIDTH);
        this.canvas.el.attr('height', canvas.HEIGHT);
    }
    newColor(){
        var this_tree = this;
        return parseInt('0x' + ("000000" + Math.random().toString(16).slice(2, 8).toUpperCase()).slice(-6))
    }
    fade(){
        var this_tree = this;
        this.canvas.ctx.alpha -= 0.02
        if (this.canvas.ctx.alpha<0.1) this.canvas.ctx.clear(this_tree);
    }
 }
    // -------------------------------//
    //       Internal functions       //
    // -------------------------------//

    // Clear the canvas
    function clear(tree_obj) {
        tree_obj.canvas.ctx.clear();
    }

    /**
     * Draw a circle
     * @param  {int}    x     Center x coordinate
     * @param  {int}    y     Center y coordinate
     * @param  {int}    rad   Radius
     * @param  {String} color HTML color
     * @return {void}
     */
    function circle(scene_obj, x, y, rad, color) {
        // Circulo
        scene_obj.canvas.ctx.lineWidth = 1;
        scene_obj.canvas.ctx.strokeStyle = color;
        scene_obj.canvas.ctx.beginPath();
        scene_obj.canvas.ctx.arc(x, y, rad, 0, Math.PI * 2, true);
        scene_obj.canvas.ctx.closePath();
        scene_obj.canvas.ctx.strokePath();
    }    
    //////
    //EFFECT TWO END
    //////







    class SceneGameOver extends Phaser.Scene {
            constructor(){
                super({ key: 'sceneGameOver' });
                }
            preload(){
                }
            create(){
                var scene_obj = this;
                reds = new J_Sprite(scene_obj, 'red').addMe(1);
                reds.red_1.x = 25
                reds.red_1.y = 25
                reds.red_1.setInteractive();
                reds.red_1.on('pointerup', function (event) {
                    this.input.manager.enabled = true;
                    this.scene.start('sceneGameOn');
                        }, this);
                }
            } 
    function newTarget(sprite){
        sprite.target = new Point(Math.random()*500, Math.random()*500);
    }; 
    function updateMe(sprite, delta){
        //Point the object at its target
        var dx = sprite.target.x - sprite.x;
        var dy = sprite.target.y - sprite.y;
        var angle = Math.atan2(dy, dx);
        sprite.rotation = angle
        //move the object in the direction its facing
        sprite.x = sprite.x+Math.cos(sprite.rotation)*delta/8
        sprite.y = sprite.y+Math.sin(sprite.rotation)*delta/8
        //calculate the distance to the target
        var hyp = Math.sqrt((dx*dx)+(dy*dy))
        //if the hyp is less then 5 pixels pick a new target
        if (hyp < 5){
            newTarget(sprite)
        }
    }
    //////
    //EFFECT ONE START
    //////
    var sprite_circle = new Phaser.Geom.Circle(0,0,3);
    var graphics_store = {};
    var effect_one_count = 50;
    var outer_circle_radius = 100;
    
    function graphicsEffectOne_pt_Init(scene_obj, sprite){
        for(var i = effect_one_count; i > 0; i--){
            var name_it = 'particle_'+i.toString();
            graphics_store[name_it] = scene_obj.add.graphics({ fillStyle: { color: 0xff0000 } });
            graphics_store[name_it].fillCircleShape(sprite_circle);
            graphics_store[name_it].x = sprite.x
            graphics_store[name_it].y = sprite.y
            scene_obj.children.bringToTop(sprite);
            graphicsEffectOne_pt_Target(sprite, graphics_store[name_it])
            //Point the object at random point on the outer circle
            var dx = graphics_store[name_it].target.x - graphics_store[name_it].x;
            var dy = graphics_store[name_it].target.y - graphics_store[name_it].y;
            var angle = Math.atan2(dy, dx);
            graphics_store[name_it].rotation = angle
            //calculate the distance to the target
            var hyp = Math.sqrt((dx*dx)+(dy*dy))
            graphics_store[name_it].x = graphics_store[name_it].x+Math.cos(graphics_store[name_it].rotation)*(outer_circle_radius*Math.random())
            graphics_store[name_it].y = graphics_store[name_it].y+Math.sin(graphics_store[name_it].rotation)*(outer_circle_radius*Math.random())
        }
    }
    function graphicsEffectOne_pt_Update(sprite, delta){
        for(var particle in graphics_store){
            //Point the particle at random point on the outer circle
            var dx = graphics_store[particle].target.x - graphics_store[particle].x;
            var dy = graphics_store[particle].target.y - graphics_store[particle].y;
            var angle = Math.atan2(dy, dx);
            graphics_store[particle].rotation = angle
            //calculate the distance to the target
            var hyp = Math.sqrt((dx*dx)+(dy*dy))
            //if the hyp is less then 5 pixels pick a new target
            if (hyp < 5){
                graphics_store[particle].x = sprite.x;
                graphics_store[particle].y = sprite.y;
                graphicsEffectOne_pt_Target(sprite, graphics_store[particle])
            }else{//move the object in the direction its facing
                var speed = 5+Math.random()*8
            graphics_store[particle].x = graphics_store[particle].x+Math.cos(graphics_store[particle].rotation)*delta/speed
            graphics_store[particle].y = graphics_store[particle].y+Math.sin(graphics_store[particle].rotation)*delta/speed
            } 
        }
    }
    function graphicsEffectOne_pt_Target(sprite, particle){
        var random_angle = Math.random()*Math.PI*2;
        var outer_circle_x = sprite.x + Math.cos(random_angle)*outer_circle_radius;
        var outer_circle_y = sprite.y + Math.sin(random_angle)*outer_circle_radius;
        var point = new Point(outer_circle_x, outer_circle_y);
        particle.target = point;
    }  
    //////
    //EFFECT ONE END
    //////

    class Point {
            constructor(x,y){
                this.x = x;
                this.y = y;
            }
        }
        class J_Sprite extends Phaser.Physics.Matter.World {
        constructor(object_scene, name_sprite){
            super({
                scene:object_scene
                });
            this.scene = object_scene;
            this.name_it = name_sprite;
            this.sprite_j = {};
            this.world = object_scene.matter.world;
            this.x = game.config.width*0.5;
            this.y = game.config.height*0.5-100;
            this.texture='sprites';
            this.frame= name_sprite.toString()+'.png';
            this.options={shape: hitboxes[name_sprite]};
        }
        addMe(num){
            for(var i=num; i > 0; i--){
                    var name_it = this.name_it+'_'+i.toString()
                    this.sprite_j[name_it] = this.scene.matter.add.sprite(this.x,this.y,this.texture,this.frame,this.options);
                    this.sprite_j[name_it].name = name_it
                }            
            return this.sprite_j;
            }
        }
        class SceneMenue extends Phaser.Scene {
            constructor(){
                super({ key: 'sceneMenue' });
            }
            preload (){
                console.log('menues are loading')
            }
            create ()
            {
                console.log("menues were loaded")
                this.scene.start('sceneGameOn');
            }
        }
        
        var config = {
        type: Phaser.AUTO,
        width: 1000,
        height: 500,
        parent: 'game',
        scene: [ SceneMenue, SceneGameOn, SceneGameOver ],
        physics: {
            default: "matter",
            matter: {
                 debug: false//true
            }
        }
        ,transparent: true
    };
    var game = new Phaser.Game(config);
    var hitboxes = null;
    var reds, forest;
</script>
</body>
</html>